<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>VirtualBox Main API: IMedium Interface Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>IMedium Interface Reference</h1><!-- doxytag: class="IMedium" -->The <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> interface represents virtual storage for a machine's hard disks, CD/DVD or floppy drives.  
<a href="#_details">More...</a>
<p>

<p>
<a href="interface_i_medium-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the current medium state (see <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a><b></b>) is one of "Created", "Inaccessible" or "LockedRead", then this performs an accessibility check on the medium and sets the value of the <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> attribute accordingly; that value is also returned for convenience.  <a href="#67c4d153a846d2633736c0ec90dc7714"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#7cfe993112605057132bc6f4b3c8cd36">getSnapshotIds</a> (in wstringUUID machineId,[retval] out wstringUUID[] snapshotIds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array of UUIDs of all snapshots of the given machine where this medium is attached to.  <a href="#7cfe993112605057132bc6f4b3c8cd36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks this medium for reading.  <a href="#13e3e174fdc7c9a4794bcb1b07e7ea79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#d6cd559fb4d6c0dedfb141847e2f16b6">unlockRead</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels the read lock previously set by <a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a><b></b>.  <a href="#d6cd559fb4d6c0dedfb141847e2f16b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks this medium for writing.  <a href="#c67ec7fce10a2b47f297334472004799"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#89bd14dea46f76b67f28d283f565b775">unlockWrite</a> ([retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels the write lock previously set by <a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a><b></b>.  <a href="#89bd14dea46f76b67f28d283f565b775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#8e006ecc7b5bc8d9d8cb281b237a8e23">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Closes this medium.  <a href="#8e006ecc7b5bc8d9d8cb281b237a8e23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#6573df3af0ce80a3fc1d3bf2aea0f80e">getProperty</a> (in wstring <a class="el" href="interface_i_medium.html#1fbf41d84302b52c2392454c60a415b8">name</a>,[retval] out wstring value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value of the custom medium property with the given name.  <a href="#6573df3af0ce80a3fc1d3bf2aea0f80e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#5e4bfcfd8544ad0ea7e372f8ab424882">setProperty</a> (in wstring <a class="el" href="interface_i_medium.html#1fbf41d84302b52c2392454c60a415b8">name</a>, in wstring value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value of the custom medium property with the given name.  <a href="#5e4bfcfd8544ad0ea7e372f8ab424882"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#1b7e7f37f9cabbbebb2ee364023bb27b">getProperties</a> (in wstring names, out wstring[] returnNames,[retval] out wstring[] returnValues)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns values for a group of properties in one call.  <a href="#1b7e7f37f9cabbbebb2ee364023bb27b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#34eea84f94452bce694f4f69f6ad9d24">setProperties</a> (in wstring[] names, in wstring[] values)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets values for a group of properties in one call.  <a href="#34eea84f94452bce694f4f69f6ad9d24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#77cba8ba896e5a89f80fb1235fb9f9f4">createBaseStorage</a> (in unsigned long long <a class="el" href="interface_i_medium.html#cf9c923afac6944394db3856544764d1">logicalSize</a>, in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a> variant,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts creating a hard disk storage unit (fixed/dynamic, according to the variant flags) in in the background.  <a href="#77cba8ba896e5a89f80fb1235fb9f9f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#94d118ff3f2ad05638d4c705532f0dce">deleteStorage</a> ([retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts deleting the storage unit of this medium.  <a href="#94d118ff3f2ad05638d4c705532f0dce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#262ed1514bacfb2bf8d5ecf2e094f718">createDiffStorage</a> (in <a class="el" href="interface_i_medium.html">IMedium</a> target, in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a> variant,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts creating an empty differencing storage unit based on this medium in the format and at the location defined by the <em>target</em> argument.  <a href="#262ed1514bacfb2bf8d5ecf2e094f718"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#aed7038739c454873f596a56b30389dd">mergeTo</a> (in <a class="el" href="interface_i_medium.html">IMedium</a> target,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts merging the contents of this medium and all intermediate differencing media in the chain to the given target medium.  <a href="#aed7038739c454873f596a56b30389dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#7c49677c7770576708ea7f05843f606b">cloneTo</a> (in <a class="el" href="interface_i_medium.html">IMedium</a> target, in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a> variant, in <a class="el" href="interface_i_medium.html">IMedium</a> <a class="el" href="interface_i_medium.html#ff2eb5e354570fc966561ba2e3fdb557">parent</a>,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts creating a clone of this medium in the format and at the location defined by the <em>target</em> argument.  <a href="#7c49677c7770576708ea7f05843f606b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#81373bdd26302231218e447f1de48d36">compact</a> ([retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts compacting of this medium.  <a href="#81373bdd26302231218e447f1de48d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#34d2bdb7ac1c55a18a20dc054da55836">resize</a> (in unsigned long long <a class="el" href="interface_i_medium.html#cf9c923afac6944394db3856544764d1">logicalSize</a>,[retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts resizing this medium.  <a href="#34d2bdb7ac1c55a18a20dc054da55836"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#fd01e6dd69a92b3aec9011f156869d89">reset</a> ([retval] out <a class="el" href="interface_i_progress.html">IProgress</a> progress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts erasing the contents of this differencing medium.  <a href="#fd01e6dd69a92b3aec9011f156869d89"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute wstringUUID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#302234bd835a0a0cb70293bbb2e9355b">id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UUID of the medium.  <a href="#302234bd835a0a0cb70293bbb2e9355b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#4de9bedf9d7d612838598903a1e4c300">description</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Optional description of the medium.  <a href="#4de9bedf9d7d612838598903a1e4c300"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current medium state, which is the last state set by the accessibility check performed by <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b>.  <a href="#c250d2252217354b21b272b9387c94d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">location</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Location of the storage unit holding medium data.  <a href="#dd0200d560c7f06631d6e979ebd8510a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#1fbf41d84302b52c2392454c60a415b8">name</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Name of the storage unit holding medium data.  <a href="#1fbf41d84302b52c2392454c60a415b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="_virtual_box_8idl.html#d258d4c51629346fceac4679b3209ad9">DeviceType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#01b3d1aa474671a6f6efc7d768e02603">deviceType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kind of device (DVD/Floppy/HardDisk) which is applicable to this medium.  <a href="#01b3d1aa474671a6f6efc7d768e02603"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#083b805a42df44c7f30dcefa8bfb0b19">hostDrive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">True if this corresponds to a drive on the host.  <a href="#083b805a42df44c7f30dcefa8bfb0b19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute unsigned <br>
long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#9ad3aaac5c492ae22205995236470499">size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Physical size of the storage unit used to hold medium data (in bytes).  <a href="#9ad3aaac5c492ae22205995236470499"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#acf66ac403576ec489410c12c701cbc7">format</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage format of this medium.  <a href="#acf66ac403576ec489410c12c701cbc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="interface_i_medium_format.html">IMediumFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#709be209ddc9fa9cbc607bfc9c9e741a">mediumFormat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage medium format object corresponding to this medium.  <a href="#709be209ddc9fa9cbc607bfc9c9e741a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">attribute <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c">MediumType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#b5430e5698b129a24c36d01fbc554cea">type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type (role) of this medium.  <a href="#b5430e5698b129a24c36d01fbc554cea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#ff2eb5e354570fc966561ba2e3fdb557">parent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parent of this medium (the medium this medium is directly based on).  <a href="#ff2eb5e354570fc966561ba2e3fdb557"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#079bf4ff8d423005179b26044a5709fa">children</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Children of this medium (all differencing media directly based on this medium).  <a href="#079bf4ff8d423005179b26044a5709fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#d1595ef4720ff87d93dab30ea0ab0f2e">base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base medium of this medium.  <a href="#d1595ef4720ff87d93dab30ea0ab0f2e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#98fcbfdaca62411eab95c8d84c21f850">readOnly</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <code>true</code> if this medium is read-only and <code>false</code> otherwise.  <a href="#98fcbfdaca62411eab95c8d84c21f850"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute unsigned <br>
long long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#cf9c923afac6944394db3856544764d1">logicalSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical size of this medium (in megabytes), as reported to the guest OS running inside the virtual machine this medium is attached to.  <a href="#cf9c923afac6944394db3856544764d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">attribute boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#ccc83be4542142dfa1aee8238b1c42ec">autoReset</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether this differencing medium will be automatically reset each time a virtual machine it is attached to is powered up.  <a href="#ccc83be4542142dfa1aee8238b1c42ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute wstring&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Text message that represents the result of the last accessibility check performed by <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b>.  <a href="#43cef7fdd6fde64c591bc9529ea6e3ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">readonly attribute wstringUUID[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_i_medium.html#e0547f6629431c9508f68115745d266e">machineIds</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array of UUIDs of all machines this medium is attached to.  <a href="#e0547f6629431c9508f68115745d266e"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> interface represents virtual storage for a machine's hard disks, CD/DVD or floppy drives. 
<p>
It will typically represent a disk image on the host, for example a VDI or VMDK file representing a virtual hard disk, or an ISO or RAW file representing virtual removable media, but can also point to a network location (e.g. for iSCSI targets).<p>
Instances of <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> are connected to virtual machines by way of medium attachments (see <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b>), which link the storage medium to a particular device slot of a storage controller of the virtual machine. In the VirtualBox API, virtual storage is therefore always represented by the following chain of object links:<p>
<ul>
<li>
<a class="el" href="interface_i_machine.html#c5638e205ed8f8a1473d3b866e9a7d4f">IMachine::storageControllers</a><b></b> contains an array of storage controllers (IDE, SATA, SCSI, SAS or a floppy controller; these are instances of <a class="el" href="interface_i_storage_controller.html">IStorageController</a><b></b>). </li>
<li>
<a class="el" href="interface_i_machine.html#ef972b7f8785c3a3f98a592a246ca4b4">IMachine::mediumAttachments</a><b></b> contains an array of medium attachments (instances of <a class="el" href="interface_i_medium_attachment.html">IMediumAttachment</a><b></b>), each containing a storage controller from the above array, a port/device specification, and an instance of <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> representing the medium storage (image file).<p>
For removable media, the storage medium is optional; a medium attachment with no medium represents a CD/DVD or floppy drive with no medium inserted. By contrast, hard disk attachments will always have an <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> object attached. </li>
<li>
Each <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> in turn points to a storage unit (such as a file on the host computer or a network resource) that holds actual data. This location is represented by the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">location</a><b></b> attribute. </li>
</ul>
<p>
Existing media are opened using the following methods, depending on the media type: <ul>
<li>
<a class="el" href="interface_i_virtual_box.html#aee5b0a056159255d9e3f268f9d6f449">IVirtualBox::openHardDisk</a><b></b>  </li>
<li>
<a class="el" href="interface_i_virtual_box.html#e4825a142dfd3406d05c4b3104124279">IVirtualBox::openDVDImage</a><b></b>  </li>
<li>
<a class="el" href="interface_i_virtual_box.html#58428676be2df62a9aa601c612022a1b">IVirtualBox::openFloppyImage</a><b></b>  </li>
</ul>
<p>
New hard disk media can be created with the VirtualBox API using the <a class="el" href="interface_i_virtual_box.html#63e62507782c9e0a6fda05d14cfbd40d">IVirtualBox::createHardDisk</a><b></b> method.<p>
CD/DVD and floppy images (ISO and RAW files) are usually created outside VirtualBox, e.g. by storing a copy of the real medium of the corresponding type in a regular file.<p>
Only for CD/DVDs and floppies, an <a class="el" href="interface_i_medium.html" title="The IMedium interface represents virtual storage for a machine&#39;s hard disks,...">IMedium</a> instance can also represent a host drive; in that case the <a class="el" href="interface_i_medium.html#302234bd835a0a0cb70293bbb2e9355b">id</a><b></b> attribute contains the UUID of one of the drives in <a class="el" href="interface_i_host.html#285b1b89c35b67a0bb52b547f5d3ebb3">IHost::DVDDrives</a><b></b> or <a class="el" href="interface_i_host.html#de0e3923823c0c8d96e7eac39748122c">IHost::floppyDrives</a><b></b>.<p>
<h3>Known media</h3>
<p>
When an existing medium is opened for the first time, it is automatically remembered by the given VirtualBox installation or, in other words, becomes a <em>known medium</em>. Known media are stored in the media registry transparently maintained by VirtualBox and stored in settings files so that this registry is preserved when VirtualBox is not running.<p>
Newly created virtual media are remembered only when the associated storage unit is actually created.<p>
All known media can be enumerated using <a class="el" href="interface_i_virtual_box.html#795457eb6321e42afb495064ee06213d">IVirtualBox::hardDisks</a><b></b>, <a class="el" href="interface_i_virtual_box.html#840614ca6ed7428c755380f0b21f1f1e">IVirtualBox::DVDImages</a><b></b> and <a class="el" href="interface_i_virtual_box.html#a120d6c1c83a80d98cfc6fc92d464c49">IVirtualBox::floppyImages</a><b></b> attributes. Individual media can be quickly found by UUID using <a class="el" href="interface_i_virtual_box.html#63e78d1bd8ef3fbbfa16fece992515c4">IVirtualBox::getHardDisk</a><b></b> and similar methods or by location using <a class="el" href="interface_i_virtual_box.html#f19c0e111ba55be5b72e8fe6cae601c4">IVirtualBox::findHardDisk</a><b></b> and similar methods.<p>
Only known media can be attached to virtual machines.<p>
Removing known media from the media registry is performed when the given medium is closed using the <a class="el" href="interface_i_medium.html#8e006ecc7b5bc8d9d8cb281b237a8e23">close</a><b></b> method or when its associated storage unit is deleted.<p>
<h3>Accessibility checks</h3>
<p>
VirtualBox defers media accessibility checks until the <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b> method is called explicitly on a medium. This is done to make the VirtualBox object ready for serving requests as fast as possible and let the end-user application decide if it needs to check media accessibility right away or not.<p>
As a result, when VirtualBox starts up (e.g. the VirtualBox object gets created for the first time), all known media are in the "Inaccessible" state, but the value of the <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a><b></b> attribute is an empty string because no actual accessibility check has been made yet.<p>
After calling <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b>, a medium is considered <em>accessible</em> if its storage unit can be read. In that case, the <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> attribute has a value of "Created". If the storage unit cannot be read (for example, because it is located on a disconnected network resource, or was accidentally deleted outside VirtualBox), the medium is considered <em>inaccessible</em>, which is indicated by the "Inaccessible" state. The exact reason why the medium is inaccessible can be obtained by reading the <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a><b></b> attribute.<p>
<h3>Medium types</h3>
<p>
There are three types of medium behavior (see <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c">MediumType</a><b></b>): "normal", "immutable" and "writethrough", represented by the <a class="el" href="interface_i_medium.html#b5430e5698b129a24c36d01fbc554cea">type</a><b></b> attribute. The type of the medium defines how the medium is attached to a virtual machine and what happens when a <a class="el" href="interface_i_snapshot.html">snapshot</a><b></b> of the virtual machine with the attached medium is taken. At the moment DVD and floppy media are always of type "writethrough".<p>
All media can be also divided in two groups: <em>base</em> media and <em>differencing</em> media. A base medium contains all sectors of the medium data in its own storage and therefore can be used independently. In contrast, a differencing mediun is a "delta" to some other medium and contains only those sectors which differ from that other medium, which is then called a <em>parent</em>. The differencing medium is said to be <em>linked to</em> that parent. The parent may be itself a differencing medium, thus forming a chain of linked media. The last element in that chain must always be a base medium. Note that several differencing media may be linked to the same parent medium.<p>
Differencing media can be distinguished from base media by querying the <a class="el" href="interface_i_medium.html#ff2eb5e354570fc966561ba2e3fdb557">parent</a><b></b> attribute: base media do not have parents they would depend on, so the value of this attribute is always <code>null</code> for them. Using this attribute, it is possible to walk up the medium tree (from the child medium to its parent). It is also possible to walk down the tree using the <a class="el" href="interface_i_medium.html#079bf4ff8d423005179b26044a5709fa">children</a><b></b> attribute.<p>
Note that the type of all differencing media is "Normal"; all other values are meaningless for them. Base media may be of any type.<p>
<h3>Creating hard disks</h3>
<p>
New base hard disks are created using <a class="el" href="interface_i_virtual_box.html#63e62507782c9e0a6fda05d14cfbd40d">IVirtualBox::createHardDisk</a><b></b>. Existing hard disks are opened using <a class="el" href="interface_i_virtual_box.html#aee5b0a056159255d9e3f268f9d6f449">IVirtualBox::openHardDisk</a><b></b>. Differencing hard disks are usually implicitly created by VirtualBox when needed but may also be created explicitly using <a class="el" href="interface_i_medium.html#262ed1514bacfb2bf8d5ecf2e094f718">createDiffStorage</a><b></b>.<p>
After the hard disk is successfully created (including the storage unit) or opened, it becomes a known hard disk (remembered in the internal media registry). Known hard disks can be attached to a virtual machine, accessed through <a class="el" href="interface_i_virtual_box.html#63e78d1bd8ef3fbbfa16fece992515c4">IVirtualBox::getHardDisk</a><b></b> and <a class="el" href="interface_i_virtual_box.html#f19c0e111ba55be5b72e8fe6cae601c4">IVirtualBox::findHardDisk</a><b></b> methods or enumerated using the <a class="el" href="interface_i_virtual_box.html#795457eb6321e42afb495064ee06213d">IVirtualBox::hardDisks</a><b></b> array (only for base hard disks).<p>
The following methods, besides <a class="el" href="interface_i_medium.html#8e006ecc7b5bc8d9d8cb281b237a8e23">IMedium::close</a><b></b>, automatically remove the hard disk from the media registry: <ul>
<li>
<a class="el" href="interface_i_medium.html#94d118ff3f2ad05638d4c705532f0dce">deleteStorage</a><b></b>  </li>
<li>
<a class="el" href="interface_i_medium.html#aed7038739c454873f596a56b30389dd">mergeTo</a><b></b>  </li>
</ul>
<p>
If the storage unit of the hard disk is a regular file in the host's file system then the rules stated in the description of the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">IMedium::location</a><b></b> attribute apply when setting its value. In addition, a plain file name without any path may be given, in which case the <a class="el" href="interface_i_system_properties.html#6e2faf26ee7982e23c413f9740c4fce3">default hard disk folder</a><b></b> will be prepended to it.<p>
<h4>Automatic composition of the file name part</h4>
<p>
Another extension to the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">IMedium::location</a><b></b> attribute is that there is a possibility to cause VirtualBox to compose a unique value for the file name part of the location using the UUID of the hard disk. This applies only to hard disks in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> state, e.g. before the storage unit is created, and works as follows. You set the value of the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">IMedium::location</a><b></b> attribute to a location specification which only contains the path specification but not the file name part and ends with either a forward slash or a backslash character. In response, VirtualBox will generate a new UUID for the hard disk and compose the file name using the following pattern: <pre>
        &lt;path&gt;/{&lt;uuid&gt;}.&lt;ext&gt;
      </pre> where <code>&lt;path&gt;</code> is the supplied path specification, <code>&lt;uuid&gt;</code> is the newly generated UUID and <code>&lt;ext&gt;</code> is the default extension for the storage format of this hard disk. After that, you may call any of the methods that create a new hard disk storage unit and they will use the generated UUID and file name.<p>
<h3>Attaching Hard Disks</h3>
<p>
Hard disks are attached to virtual machines using the <a class="el" href="interface_i_machine.html#92b861a57dd2e4c8d788092305307633">IMachine::attachDevice</a><b></b> method and detached using the <a class="el" href="interface_i_machine.html#59a8e406027e901cc260488f8617fb22">IMachine::detachDevice</a><b></b> method. Depending on their <a class="el" href="interface_i_medium.html#b5430e5698b129a24c36d01fbc554cea">type</a><b></b>, hard disks are attached either <em>directly</em> or <em>indirectly</em>.<p>
When a hard disk is being attached directly, it is associated with the virtual machine and used for hard disk operations when the machine is running. When a hard disk is being attached indirectly, a new differencing hard disk linked to it is implicitly created and this differencing hard disk is associated with the machine and used for hard disk operations. This also means that if <a class="el" href="interface_i_machine.html#92b861a57dd2e4c8d788092305307633">IMachine::attachDevice</a><b></b> performs a direct attachment then the same hard disk will be returned in response to the subsequent <a class="el" href="interface_i_machine.html#23f94c1e7ed8dcd36cf38ae5c7eec9ed">IMachine::getMedium</a><b></b> call; however if an indirect attachment is performed then <a class="el" href="interface_i_machine.html#23f94c1e7ed8dcd36cf38ae5c7eec9ed">IMachine::getMedium</a><b></b> will return the implicitly created differencing hard disk, not the original one passed to <a class="el" href="interface_i_machine.html#92b861a57dd2e4c8d788092305307633">IMachine::attachDevice</a><b></b>. In detail:<p>
<ul>
<li>
<b>Normal base</b> hard disks that do not have children (i.e. differencing hard disks linked to them) and that are not already attached to virtual machines in snapshots are attached <b>directly</b>. Otherwise, they are attached <b>indirectly</b> because having dependent children or being part of the snapshot makes it impossible to modify hard disk contents without breaking the integrity of the dependent party. The <a class="el" href="interface_i_medium.html#98fcbfdaca62411eab95c8d84c21f850">readOnly</a><b></b> attribute allows to quickly determine the kind of the attachment for the given hard disk. Note that if a normal base hard disk is to be indirectly attached to a virtual machine with snapshots then a special procedure called <em>smart attachment</em> is performed (see below). </li>
<li>
<b>Normal differencing</b> hard disks are like normal base hard disks: they are attached <b>directly</b> if they do not have children and are not attached to virtual machines in snapshots, and <b>indirectly</b> otherwise. Note that the smart attachment procedure is never performed for differencing hard disks. </li>
<li>
<b>Immutable</b> hard disks are always attached <b>indirectly</b> because they are designed to be non-writable. If an immutable hard disk is attached to a virtual machine with snapshots then a special procedure called smart attachment is performed (see below). </li>
<li>
<b>Writethrough</b> hard disks are always attached <b>directly</b>, also as designed. This also means that writethrough hard disks cannot have other hard disks linked to them at all. </li>
</ul>
<p>
Note that the same hard disk, regardless of its type, may be attached to more than one virtual machine at a time. In this case, the machine that is started first gains exclusive access to the hard disk and attempts to start other machines having this hard disk attached will fail until the first machine is powered down.<p>
Detaching hard disks is performed in a <em>deferred</em> fashion. This means that the given hard disk remains associated with the given machine after a successful <a class="el" href="interface_i_machine.html#59a8e406027e901cc260488f8617fb22">IMachine::detachDevice</a><b></b> call until <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b> is called to save all changes to machine settings to disk. This deferring is necessary to guarantee that the hard disk configuration may be restored at any time by a call to <a class="el" href="interface_i_machine.html#341ac035501a0c168ad9571bbe86eb02">IMachine::discardSettings</a><b></b> before the settings are saved (committed).<p>
Note that if <a class="el" href="interface_i_machine.html#341ac035501a0c168ad9571bbe86eb02">IMachine::discardSettings</a><b></b> is called after indirectly attaching some hard disks to the machine but before a call to <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b> is made, it will implicitly delete all differencing hard disks implicitly created by <a class="el" href="interface_i_machine.html#92b861a57dd2e4c8d788092305307633">IMachine::attachDevice</a><b></b> for these indirect attachments. Such implicitly created hard disks will also be immediately deleted when detached explicitly using the <a class="el" href="interface_i_machine.html#59a8e406027e901cc260488f8617fb22">IMachine::detachDevice</a><b></b> call if it is made before <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b>. This implicit deletion is safe because newly created differencing hard disks do not contain any user data.<p>
However, keep in mind that detaching differencing hard disks that were implicitly created by <a class="el" href="interface_i_machine.html#92b861a57dd2e4c8d788092305307633">IMachine::attachDevice</a><b></b> before the last <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b> call will <b>not</b> implicitly delete them as they may already contain some data (for example, as a result of virtual machine execution). If these hard disks are no more necessary, the caller can always delete them explicitly using <a class="el" href="interface_i_medium.html#94d118ff3f2ad05638d4c705532f0dce">deleteStorage</a><b></b> after they are actually de-associated from this machine by the <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b> call.<p>
<h3>Smart Attachment</h3>
<p>
When normal base or immutable hard disks are indirectly attached to a virtual machine then some additional steps are performed to make sure the virtual machine will have the most recent "view" of the hard disk being attached. These steps include walking through the machine's snapshots starting from the current one and going through ancestors up to the first snapshot. Hard disks attached to the virtual machine in all of the encountered snapshots are checked whether they are descendants of the given normal base or immutable hard disk. The first found child (which is the differencing hard disk) will be used instead of the normal base or immutable hard disk as a parent for creating a new differencing hard disk that will be actually attached to the machine. And only if no descendants are found or if the virtual machine does not have any snapshots then the normal base or immutable hard disk will be used itself as a parent for this differencing hard disk.<p>
It is easier to explain what smart attachment does using the following example: <pre>
BEFORE attaching B.vdi:       AFTER attaching B.vdi:</pre><p>
<pre>Snapshot 1 (B.vdi)            Snapshot 1 (B.vdi)
 Snapshot 2 (D1-&gt;B.vdi)        Snapshot 2 (D1-&gt;B.vdi)
  Snapshot 3 (D2-&gt;D1.vdi)       Snapshot 3 (D2-&gt;D1.vdi)
   Snapshot 4 (none)             Snapshot 4 (none)
    CurState   (none)             CurState   (D3-&gt;D2.vdi)</pre><p>
<pre>                              NOT
                                 ...
                                  CurState   (D3-&gt;B.vdi)
      </pre> The first column is the virtual machine configuration before the base hard disk <code>B.vdi</code> is attached, the second column shows the machine after this hard disk is attached. Constructs like <code>D1-&gt;B.vdi</code> and similar mean that the hard disk that is actually attached to the machine is a differencing hard disk, <code>D1.vdi</code>, which is linked to (based on) another hard disk, <code>B.vdi</code>.<p>
As we can see from the example, the hard disk <code>B.vdi</code> was detached from the machine before taking Snapshot 4. Later, after Snapshot 4 was taken, the user decides to attach <code>B.vdi</code> again. <code>B.vdi</code> has dependent child hard disks (<code>D1.vdi</code>, <code>D2.vdi</code>), therefore it cannot be attached directly and needs an indirect attachment (i.e. implicit creation of a new differencing hard disk). Due to the smart attachment procedure, the new differencing hard disk (<code>D3.vdi</code>) will be based on <code>D2.vdi</code>, not on <code>B.vdi</code> itself, since <code>D2.vdi</code> is the most recent view of <code>B.vdi</code> existing for this snapshot branch of the given virtual machine.<p>
Note that if there is more than one descendant hard disk of the given base hard disk found in a snapshot, and there is an exact device, channel and bus match, then this exact match will be used. Otherwise, the youngest descendant will be picked up.<p>
There is one more important aspect of the smart attachment procedure which is not related to snapshots at all. Before walking through the snapshots as described above, the backup copy of the current list of hard disk attachment is searched for descendants. This backup copy is created when the hard disk configuration is changed for the first time after the last <a class="el" href="interface_i_machine.html#2eb47e1d878566569b26893cc12bd8e1">IMachine::saveSettings</a><b></b> call and used by <a class="el" href="interface_i_machine.html#341ac035501a0c168ad9571bbe86eb02">IMachine::discardSettings</a><b></b> to undo the recent hard disk changes. When such a descendant is found in this backup copy, it will be simply re-attached back, without creating a new differencing hard disk for it. This optimization is necessary to make it possible to re-attach the base or immutable hard disk to a different bus, channel or device slot without losing the contents of the differencing hard disk actually attached to the machine in place of it.<p>
<dl class="user" compact><dt><b>Interface ID:</b></dt><dd><code>{1D578F43-5EF1-4415-B556-7592D3CCDC8F}</code> </dd></dl>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="67c4d153a846d2633736c0ec90dc7714"></a><!-- doxytag: member="IMedium::refreshState" ref="67c4d153a846d2633736c0ec90dc7714" args="([retval] out MediumState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::refreshState           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the current medium state (see <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a><b></b>) is one of "Created", "Inaccessible" or "LockedRead", then this performs an accessibility check on the medium and sets the value of the <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> attribute accordingly; that value is also returned for convenience. 
<p>
For all other state values, this does not perform a refresh but returns the state only.<p>
The refresh, if performed, may take a long time (several seconds or even minutes, depending on the storage unit location and format) because it performs an accessibility check of the storage unit. This check may cause a significant delay if the storage unit of the given medium is, for example, a file located on a network share which is not currently accessible due to connectivity problems. In that case, the call will not return until a timeout interval defined by the host OS for this operation expires. For this reason, it is recommended to never read this attribute on the main UI thread to avoid making the UI unresponsive.<p>
If the last known state of the medium is "Created" and the accessibility check fails, then the state would be set to "Inaccessible", and <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a><b></b> may be used to get more details about the failure. If the state of the medium is "LockedRead", then it remains the same, and a non-empty value of <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a><b></b> will indicate a failed accessibility check in this case.<p>
Note that not all medium states are applicable to all medium types.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>New medium state. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7cfe993112605057132bc6f4b3c8cd36"></a><!-- doxytag: member="IMedium::getSnapshotIds" ref="7cfe993112605057132bc6f4b3c8cd36" args="(in wstringUUID machineId,[retval] out wstringUUID[] snapshotIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::getSnapshotIds           </td>
          <td>(</td>
          <td class="paramtype">in wstringUUID&nbsp;</td>
          <td class="paramname"> <em>machineId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstringUUID[]&nbsp;</td>
          <td class="paramname"> <em>snapshotIds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an array of UUIDs of all snapshots of the given machine where this medium is attached to. 
<p>
If the medium is attached to the machine in the current state, then the first element in the array will always be the ID of the queried machine (i.e. the value equal to the <code>machineId</code> argument), followed by snapshot IDs (if any).<p>
If the medium is not attached to the machine in the current state, then the array will contain only snapshot IDs.<p>
The returned array may be <code>null</code> if this medium is not attached to the given machine at all, neither in the current state nor in one of the snapshots.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>machineId</em>&nbsp;</td><td>UUID of the machine to query.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>snapshotIds</em>&nbsp;</td><td>Array of snapshot UUIDs of the given machine using this medium. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="13e3e174fdc7c9a4794bcb1b07e7ea79"></a><!-- doxytag: member="IMedium::lockRead" ref="13e3e174fdc7c9a4794bcb1b07e7ea79" args="([retval] out MediumState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::lockRead           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks this medium for reading. 
<p>
A read lock is shared: many clients can simultaneously lock the same medium for reading unless it is already locked for writing (see <a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a><b></b>) in which case an error is returned.<p>
When the medium is locked for reading, it cannot be modified from within VirtualBox. This means that any method that changes the properties of this medium or contents of the storage unit will return an error (unless explicitly stated otherwise). That includes an attempt to start a virtual machine that wants to write to the the medium.<p>
When the virtual machine is started up, it locks for reading all media it uses in read-only mode. If some medium cannot be locked for reading, the startup procedure will fail. A medium is typically locked for reading while it is used by a running virtual machine but has a depending differencing image that receives the actual write operations. This way one base medium can have multiple child differencing images which can be written to simultaneously. Read-only media such as DVD and floppy images are also locked for reading only (so they can be in use by multiple machines simultaneously).<p>
A medium is also locked for reading when it is the source of a write operation such as <a class="el" href="interface_i_medium.html#7c49677c7770576708ea7f05843f606b">cloneTo</a><b></b> or <a class="el" href="interface_i_medium.html#aed7038739c454873f596a56b30389dd">mergeTo</a><b></b>.<p>
The medium locked for reading must be unlocked using the <a class="el" href="interface_i_medium.html#d6cd559fb4d6c0dedfb141847e2f16b6">unlockRead</a><b></b> method. Calls to <a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a><b></b> can be nested and must be followed by the same number of paired <a class="el" href="interface_i_medium.html#d6cd559fb4d6c0dedfb141847e2f16b6">unlockRead</a><b></b> calls.<p>
This method sets the medium state (see <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b>) to "LockedRead" on success. The medium's previous state must be one of "Created", "Inaccessible" or "LockedRead".<p>
Locking an inaccessible medium is not an error; this method performs a logical lock that prevents modifications of this medium through the VirtualBox API, not a physical file-system lock of the underlying storage unit.<p>
This method returns the current state of the medium <em>before</em> the operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>State of the medium after the operation.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Invalid medium state (e.g. not created, locked, inaccessible, creating, deleting).  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="d6cd559fb4d6c0dedfb141847e2f16b6"></a><!-- doxytag: member="IMedium::unlockRead" ref="d6cd559fb4d6c0dedfb141847e2f16b6" args="([retval] out MediumState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::unlockRead           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels the read lock previously set by <a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a><b></b>. 
<p>
For both success and failure, this method returns the current state of the medium <em>after</em> the operation.<p>
See <a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a><b></b> for more details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>State of the medium after the operation.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Medium not locked for reading.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c67ec7fce10a2b47f297334472004799"></a><!-- doxytag: member="IMedium::lockWrite" ref="c67ec7fce10a2b47f297334472004799" args="([retval] out MediumState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::lockWrite           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks this medium for writing. 
<p>
A write lock, as opposed to <a class="el" href="interface_i_medium.html#13e3e174fdc7c9a4794bcb1b07e7ea79">lockRead</a><b></b>, is exclusive: there may be only one client holding a write lock, and there may be no read locks while the write lock is held. As a result, read-locking fails if a write lock is held, and write-locking fails if either a read or another write lock is held.<p>
When a medium is locked for writing, it cannot be modified from within VirtualBox, and it is not guaranteed that the values of its properties are up-to-date. Any method that changes the properties of this medium or contents of the storage unit will return an error (unless explicitly stated otherwise).<p>
When a virtual machine is started up, it locks for writing all media it uses to write data to. If any medium could not be locked for writing, the startup procedure will fail. If a medium has differencing images, then while the machine is running, only the last ("leaf") differencing image is locked for writing, whereas its parents are locked for reading only.<p>
A medium is also locked for writing when it is the target of a write operation such as <a class="el" href="interface_i_medium.html#7c49677c7770576708ea7f05843f606b">cloneTo</a><b></b> or <a class="el" href="interface_i_medium.html#aed7038739c454873f596a56b30389dd">mergeTo</a><b></b>.<p>
The medium locked for writing must be unlocked using the <a class="el" href="interface_i_medium.html#89bd14dea46f76b67f28d283f565b775">unlockWrite</a><b></b> method. Write locks <em>cannot</em> be nested.<p>
This method sets the medium state (see <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b>) to "LockedWrite" on success. The medium's previous state must be either "Created" or "Inaccessible".<p>
Locking an inaccessible medium is not an error; this method performs a logical lock that prevents modifications of this medium through the VirtualBox API, not a physical file-system lock of the underlying storage unit.<p>
For both, success and failure, this method returns the current state of the medium <em>before</em> the operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>State of the medium after the operation.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Invalid medium state (e.g. not created, locked, inaccessible, creating, deleting).  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="89bd14dea46f76b67f28d283f565b775"></a><!-- doxytag: member="IMedium::unlockWrite" ref="89bd14dea46f76b67f28d283f565b775" args="([retval] out MediumState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::unlockWrite           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancels the write lock previously set by <a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a><b></b>. 
<p>
For both success and failure, this method returns the current state of the medium <em>after</em> the operation.<p>
See <a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a><b></b> for more details.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>State of the medium after the operation.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Medium not locked for writing.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="8e006ecc7b5bc8d9d8cb281b237a8e23"></a><!-- doxytag: member="IMedium::close" ref="8e006ecc7b5bc8d9d8cb281b237a8e23" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Closes this medium. 
<p>
The medium must not be attached to any known virtual machine and must not have any known child media, otherwise the operation will fail.<p>
When the medium is successfully closed, it gets removed from the list of remembered media, but its storage unit is not deleted. In particular, this means that this medium can be later opened again using the <a class="el" href="interface_i_virtual_box.html#aee5b0a056159255d9e3f268f9d6f449">IVirtualBox::openHardDisk</a><b></b> call.<p>
Note that after this method successfully returns, the given medium object becomes uninitialized. This means that any attempt to call any of its methods or attributes will fail with the <code>"Object not ready" (E_ACCESSDENIED)</code> error.<p>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Invalid medium state (other than not created, created or inaccessible).   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Medium attached to virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g1b9c9362e6dbe4403c321c0e6f1a28ad">VBOX_E_FILE_ERROR </a> </td><td>Settings file not accessible.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6f99ff1b7776c89e6433f7c827eaef67">VBOX_E_XML_ERROR </a> </td><td>Could not parse the settings file.   </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="6573df3af0ce80a3fc1d3bf2aea0f80e"></a><!-- doxytag: member="IMedium::getProperty" ref="6573df3af0ce80a3fc1d3bf2aea0f80e" args="(in wstring name,[retval] out wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::getProperty           </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value of the custom medium property with the given name. 
<p>
The list of all properties supported by the given medium format can be obtained with <a class="el" href="interface_i_medium_format.html#686c3313706bc192cd83280ebe70ec2d">IMediumFormat::describeProperties</a><b></b>.<p>
Note that if this method returns an empty string in <em>value</em>, the requested property is supported but currently not assigned any value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the property to get.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Current property value.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>Requested property does not exist (not supported by the format).   </td></tr>
<tr>
<td>E_INVALIDARG </td><td><em>name</em> is <code>null</code> or empty.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5e4bfcfd8544ad0ea7e372f8ab424882"></a><!-- doxytag: member="IMedium::setProperty" ref="5e4bfcfd8544ad0ea7e372f8ab424882" args="(in wstring name, in wstring value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::setProperty           </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the value of the custom medium property with the given name. 
<p>
The list of all properties supported by the given medium format can be obtained with <a class="el" href="interface_i_medium_format.html#686c3313706bc192cd83280ebe70ec2d">IMediumFormat::describeProperties</a><b></b>.<p>
Note that setting the property value to <code>null</code> or an empty string is equivalent to deleting the existing value. A default value (if it is defined for this property) will be used by the format backend in this case.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Name of the property to set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>Property value to set.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g80982f93e26785a807034131de6cfba5">VBOX_E_OBJECT_NOT_FOUND </a> </td><td>Requested property does not exist (not supported by the format).   </td></tr>
<tr>
<td>E_INVALIDARG </td><td><em>name</em> is <code>null</code> or empty.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="1b7e7f37f9cabbbebb2ee364023bb27b"></a><!-- doxytag: member="IMedium::getProperties" ref="1b7e7f37f9cabbbebb2ee364023bb27b" args="(in wstring names, out wstring[] returnNames,[retval] out wstring[] returnValues)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::getProperties           </td>
          <td>(</td>
          <td class="paramtype">in wstring&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">out wstring[]&nbsp;</td>
          <td class="paramname"> <em>returnNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out wstring[]&nbsp;</td>
          <td class="paramname"> <em>returnValues</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns values for a group of properties in one call. 
<p>
The names of the properties to get are specified using the <em>names</em> argument which is a list of comma-separated property names or an empty string if all properties are to be returned. Note that currently the value of this argument is ignored and the method always returns all existing properties.<p>
The list of all properties supported by the given medium format can be obtained with <a class="el" href="interface_i_medium_format.html#686c3313706bc192cd83280ebe70ec2d">IMediumFormat::describeProperties</a><b></b>.<p>
The method returns two arrays, the array of property names corresponding to the <em>names</em> argument and the current values of these properties. Both arrays have the same number of elements with each elemend at the given index in the first array corresponds to an element at the same index in the second array.<p>
Note that for properties that do not have assigned values, an empty string is returned at the appropriate index in the <em>returnValues</em> array.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>Names of properties to get.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returnNames</em>&nbsp;</td><td>Names of returned properties.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>returnValues</em>&nbsp;</td><td>Values of returned properties. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="34eea84f94452bce694f4f69f6ad9d24"></a><!-- doxytag: member="IMedium::setProperties" ref="34eea84f94452bce694f4f69f6ad9d24" args="(in wstring[] names, in wstring[] values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::setProperties           </td>
          <td>(</td>
          <td class="paramtype">in wstring[]&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in wstring[]&nbsp;</td>
          <td class="paramname"> <em>values</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets values for a group of properties in one call. 
<p>
The names of the properties to set are passed in the <em>names</em> array along with the new values for them in the <em>values</em> array. Both arrays have the same number of elements with each elemend at the given index in the first array corresponding to an element at the same index in the second array.<p>
If there is at least one property name in <em>names</em> that is not valid, the method will fail before changing the values of any other properties from the <em>names</em> array.<p>
Using this method over <a class="el" href="interface_i_medium.html#5e4bfcfd8544ad0ea7e372f8ab424882">setProperty</a><b></b> is preferred if you need to set several properties at once since it will result into less IPC calls.<p>
The list of all properties supported by the given medium format can be obtained with <a class="el" href="interface_i_medium_format.html#686c3313706bc192cd83280ebe70ec2d">IMediumFormat::describeProperties</a><b></b>.<p>
Note that setting the property value to <code>null</code> or an empty string is equivalent to deleting the existing value. A default value (if it is defined for this property) will be used by the format backend in this case.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>Names of properties to set.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>values</em>&nbsp;</td><td>Values of properties to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="77cba8ba896e5a89f80fb1235fb9f9f4"></a><!-- doxytag: member="IMedium::createBaseStorage" ref="77cba8ba896e5a89f80fb1235fb9f9f4" args="(in unsigned long long logicalSize, in MediumVariant variant,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::createBaseStorage           </td>
          <td>(</td>
          <td class="paramtype">in unsigned long long&nbsp;</td>
          <td class="paramname"> <em>logicalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a>&nbsp;</td>
          <td class="paramname"> <em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts creating a hard disk storage unit (fixed/dynamic, according to the variant flags) in in the background. 
<p>
The previous storage unit created for this object, if any, must first be deleted using <a class="el" href="interface_i_medium.html#94d118ff3f2ad05638d4c705532f0dce">deleteStorage</a><b></b>, otherwise the operation will fail.<p>
Before the operation starts, the medium is placed in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57d12405b12c0f570d4101345ba74778e6">MediumState_Creating</a><b></b> state. If the create operation fails, the medium will be placed back in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> state.<p>
After the returned progress object reports that the operation has successfully completed, the medium state will be set to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575aea3d2015c9cfc944f4e83f49c28d5c">MediumState_Created</a><b></b>, the medium will be remembered by this VirtualBox installation and may be attached to virtual machines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>logicalSize</em>&nbsp;</td><td>Maximum logical size of the medium in megabytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variant</em>&nbsp;</td><td>Exact image variant which should be created.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>The variant of storage creation operation is not supported. See <a class="el" href="interface_i_medium_format.html#d199ed98edf118889fc8cef1485a65c3">IMediumFormat::capabilities</a><b></b>.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="94d118ff3f2ad05638d4c705532f0dce"></a><!-- doxytag: member="IMedium::deleteStorage" ref="94d118ff3f2ad05638d4c705532f0dce" args="([retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::deleteStorage           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts deleting the storage unit of this medium. 
<p>
The medium must not be attached to any known virtual machine and must not have any known child media, otherwise the operation will fail. It will also fail if there is no storage unit to delete or if deletion is already in progress, or if the medium is being in use (locked for read or for write) or inaccessible. Therefore, the only valid state for this operation to succeed is <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575aea3d2015c9cfc944f4e83f49c28d5c">MediumState_Created</a><b></b>.<p>
Before the operation starts, the medium is placed in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57201f668c0d48983093fe0bd5d085787e">MediumState_Deleting</a><b></b> state and gets removed from the list of remembered hard disks (media registry). If the delete operation fails, the medium will be remembered again and placed back to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575aea3d2015c9cfc944f4e83f49c28d5c">MediumState_Created</a><b></b> state.<p>
After the returned progress object reports that the operation is complete, the medium state will be set to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> and you will be able to use one of the storage creation methods to create it again.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Medium is attached to a virtual machine.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Storage deletion is not allowed because neither of storage creation operations are supported. See <a class="el" href="interface_i_medium_format.html#d199ed98edf118889fc8cef1485a65c3">IMediumFormat::capabilities</a><b></b>.   </td></tr>
</table>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the deletion operation fails, it is not guaranteed that the storage unit still exists. You may check the <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">IMedium::state</a><b></b> value to answer this question.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="interface_i_medium.html#8e006ecc7b5bc8d9d8cb281b237a8e23" title="Closes this medium.">close()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="262ed1514bacfb2bf8d5ecf2e094f718"></a><!-- doxytag: member="IMedium::createDiffStorage" ref="262ed1514bacfb2bf8d5ecf2e094f718" args="(in IMedium target, in MediumVariant variant,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::createDiffStorage           </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a>&nbsp;</td>
          <td class="paramname"> <em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts creating an empty differencing storage unit based on this medium in the format and at the location defined by the <em>target</em> argument. 
<p>
The target medium must be in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> state (i.e. must not have an existing storage unit). Upon successful completion, this operation will set the type of the target medium to <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c629ba33e5d60a819e20c7c01913e4e39">MediumType_Normal</a><b></b> and create a storage unit necessary to represent the differencing medium data in the given format (according to the storage format of the target object).<p>
After the returned progress object reports that the operation is successfully complete, the target medium gets remembered by this VirtualBox installation and may be attached to virtual machines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target medium.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variant</em>&nbsp;</td><td>Exact image variant which should be created.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g81aa5d056e6fdac2d4f2fc4089957253">VBOX_E_OBJECT_IN_USE </a> </td><td>Medium not in <code>NotCreated</code> state.  </td></tr>
</table>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The medium will be set to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a576496c551b7ef8980d63e31784af3e500">MediumState_LockedRead</a><b></b> state for the duration of this operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aed7038739c454873f596a56b30389dd"></a><!-- doxytag: member="IMedium::mergeTo" ref="aed7038739c454873f596a56b30389dd" args="(in IMedium target,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::mergeTo           </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts merging the contents of this medium and all intermediate differencing media in the chain to the given target medium. 
<p>
The target medium must be either a descendant of this medium or its ancestor (otherwise this method will immediately return a failure). It follows that there are two logical directions of the merge operation: from ancestor to descendant (<em>forward merge</em>) and from descendant to ancestor (<em>backward merge</em>). Let us consider the following medium chain:<p>
<pre>Base &lt;- Diff_1 &lt;- Diff_2</pre><p>
Here, calling this method on the <code>Base</code> medium object with <code>Diff_2</code> as an argument will be a forward merge; calling it on <code>Diff_2</code> with <code>Base</code> as an argument will be a backward merge. Note that in both cases the contents of the resulting medium will be the same, the only difference is the medium object that takes the result of the merge operation. In case of the forward merge in the above example, the result will be written to <code>Diff_2</code>; in case of the backward merge, the result will be written to <code>Base</code>. In other words, the result of the operation is always stored in the target medium.<p>
Upon successful operation completion, the storage units of all media in the chain between this (source) medium and the target medium, including the source medium itself, will be automatically deleted and the relevant medium objects (including this medium) will become uninitialized. This means that any attempt to call any of their methods or attributes will fail with the <code>"Object not ready" (E_ACCESSDENIED)</code> error. Applied to the above example, the forward merge of <code>Base</code> to <code>Diff_2</code> will delete and uninitialize both <code>Base</code> and <code>Diff_1</code> media. Note that <code>Diff_2</code> in this case will become a base medium itself since it will no longer be based on any other medium.<p>
Considering the above, all of the following conditions must be met in order for the merge operation to succeed: <ul>
<li>
Neither this (source) medium nor any intermediate differencing medium in the chain between it and the target medium is attached to any virtual machine.  </li>
<li>
Neither the source medium nor the target medium is an <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191cc24c7a9b514f4dad4bed5c2c81ef372b">MediumType_Immutable</a><b></b> medium.  </li>
<li>
The part of the medium tree from the source medium to the target medium is a linear chain, i.e. all medium in this chain have exactly one child which is the next medium in this chain. The only exception from this rule is the target medium in the forward merge operation; it is allowed to have any number of child media because the merge operation will not change its logical contents (as it is seen by the guest OS or by children).  </li>
<li>
None of the involved media are in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a576496c551b7ef8980d63e31784af3e500">MediumState_LockedRead</a><b></b> or <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57f0144be15ca579bfb7850ccae8737a78">MediumState_LockedWrite</a><b></b> state.  </li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target medium.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This (source) medium and all intermediates will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57201f668c0d48983093fe0bd5d085787e">MediumState_Deleting</a><b></b> state and the target medium will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57f0144be15ca579bfb7850ccae8737a78">MediumState_LockedWrite</a><b></b> state and for the duration of this operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c49677c7770576708ea7f05843f606b"></a><!-- doxytag: member="IMedium::cloneTo" ref="7c49677c7770576708ea7f05843f606b" args="(in IMedium target, in MediumVariant variant, in IMedium parent,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::cloneTo           </td>
          <td>(</td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="_virtual_box_8idl.html#dedcbf1a6e5e35fe7a0ca0c4b3447154">MediumVariant</a>&nbsp;</td>
          <td class="paramname"> <em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">in <a class="el" href="interface_i_medium.html">IMedium</a>&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts creating a clone of this medium in the format and at the location defined by the <em>target</em> argument. 
<p>
The target medium must be either in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> state (i.e. must not have an existing storage unit) or in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575aea3d2015c9cfc944f4e83f49c28d5c">MediumState_Created</a><b></b> state (i.e. created and not locked, and big enough to hold the data or else the copy will be partial). Upon successful completion, the cloned medium will contain exactly the same sector data as the medium being cloned, except that in the first case a new UUID for the clone will be randomly generated, and in the second case the UUID will remain unchanged.<p>
The <em>parent</em> argument defines which medium will be the parent of the clone. Passing a <code>null</code> reference indicates that the clone will be a base image, i.e. completely independent. It is possible to specify an arbitrary medium for this parameter, including the parent of the medium which is being cloned. Even cloning to a child of the source medium is possible. Note that when cloning to an existing image, the <em>parent</em> irgument is ignored.<p>
After the returned progress object reports that the operation is successfully complete, the target medium gets remembered by this VirtualBox installation and may be attached to virtual machines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target medium.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>variant</em>&nbsp;</td><td>Exact image variant which should be created.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Parent of the cloned medium.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>E_NOTIMPL </td><td>The specified cloning variant is not supported at the moment.  </td></tr>
</table>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This medium will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a576496c551b7ef8980d63e31784af3e500">MediumState_LockedRead</a><b></b> state for the duration of this operation. </dd></dl>

</div>
</div><p>
<a class="anchor" name="81373bdd26302231218e447f1de48d36"></a><!-- doxytag: member="IMedium::compact" ref="81373bdd26302231218e447f1de48d36" args="([retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::compact           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts compacting of this medium. 
<p>
This means that the medium is transformed into a possibly more compact storage representation. This potentially creates temporary images, which can require a substantial amount of additional disk space.<p>
This medium will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57f0144be15ca579bfb7850ccae8737a78">MediumState_LockedWrite</a><b></b> state and all its parent media (if any) will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a576496c551b7ef8980d63e31784af3e500">MediumState_LockedRead</a><b></b> state for the duration of this operation.<p>
Please note that the results can be either returned straight away, or later as the result of the background operation via the object returned via the <em>progress</em> parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Medium format does not support compacting (but potentially needs it).  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="34d2bdb7ac1c55a18a20dc054da55836"></a><!-- doxytag: member="IMedium::resize" ref="34d2bdb7ac1c55a18a20dc054da55836" args="(in unsigned long long logicalSize,[retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::resize           </td>
          <td>(</td>
          <td class="paramtype">in unsigned long long&nbsp;</td>
          <td class="paramname"> <em>logicalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts resizing this medium. 
<p>
This means that the nominal size of the medium is set to the new value. Both increasing and decreasing the size is possible, and there are no safety checks, since VirtualBox does not make any assumptions about the medium contents.<p>
Resizing usually needs additional disk space, and possibly also some temporary disk space. Note that resize does not create a full temporary copy of the medium, so the additional disk space requirement is usually much lower than using the clone operation.<p>
This medium will be placed to <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57f0144be15ca579bfb7850ccae8737a78">MediumState_LockedWrite</a><b></b> state for the duration of this operation.<p>
Please note that the results can be either returned straight away, or later as the result of the background operation via the object returned via the <em>progress</em> parameter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>logicalSize</em>&nbsp;</td><td>New nominal capacity of the medium in megabytes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>Medium format does not support resizing.  </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="fd01e6dd69a92b3aec9011f156869d89"></a><!-- doxytag: member="IMedium::reset" ref="fd01e6dd69a92b3aec9011f156869d89" args="([retval] out IProgress progress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMedium::reset           </td>
          <td>(</td>
          <td class="paramtype">[retval] out <a class="el" href="interface_i_progress.html">IProgress</a>&nbsp;</td>
          <td class="paramname"> <em>progress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts erasing the contents of this differencing medium. 
<p>
This operation will reset the differencing medium to its initial state when it does not contain any sector data and any read operation is redirected to its parent medium. This automatically gets called during VM power-up for every medium whose <a class="el" href="interface_i_medium.html#ccc83be4542142dfa1aee8238b1c42ec">autoReset</a><b></b> attribute is <code>true</code>.<p>
The medium will be write-locked for the duration of this operation (see <a class="el" href="interface_i_medium.html#c67ec7fce10a2b47f297334472004799">lockWrite</a><b></b>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>progress</em>&nbsp;</td><td>Progress object to track the operation completion.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>This is not a differencing medium.   </td></tr>
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#g6660966bcbac1dcdedef5358eaf85e31">VBOX_E_INVALID_OBJECT_STATE </a> </td><td>Medium is not in <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575aea3d2015c9cfc944f4e83f49c28d5c">MediumState_Created</a><b></b> or <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575897a4ce4f8bb3050332d3eb020e98a3">MediumState_Inaccessible</a><b></b> state.   </td></tr>
</table>
</dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="302234bd835a0a0cb70293bbb2e9355b"></a><!-- doxytag: member="IMedium::id" ref="302234bd835a0a0cb70293bbb2e9355b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstringUUID <a class="el" href="interface_i_medium.html#302234bd835a0a0cb70293bbb2e9355b">IMedium::id</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UUID of the medium. 
<p>
For a newly created medium, this value is a randomly generated UUID.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For media in one of MediumState_NotCreated, MediumState_Creating or MediumState_Deleting states, the value of this property is undefined and will most likely be an empty UUID. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4de9bedf9d7d612838598903a1e4c300"></a><!-- doxytag: member="IMedium::description" ref="4de9bedf9d7d612838598903a1e4c300" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_medium.html#4de9bedf9d7d612838598903a1e4c300">IMedium::description</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Optional description of the medium. 
<p>
For a newly created medium the value of this attribute is an empty string.<p>
Medium types that don't support this attribute will return E_NOTIMPL in attempt to get or set this attribute's value.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For some storage types, reading this attribute may return an outdated (last known) value when <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> is <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575897a4ce4f8bb3050332d3eb020e98a3">MediumState_Inaccessible</a><b></b> or <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57f0144be15ca579bfb7850ccae8737a78">MediumState_LockedWrite</a><b></b> because the value of this attribute is stored within the storage unit itself. Also note that changing the attribute value is not possible in such case, as well as when the medium is the <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a576496c551b7ef8980d63e31784af3e500">MediumState_LockedRead</a><b></b> state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c250d2252217354b21b272b9387c94d4"></a><!-- doxytag: member="IMedium::state" ref="c250d2252217354b21b272b9387c94d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57">MediumState</a> <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">IMedium::state</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current medium state, which is the last state set by the accessibility check performed by <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b>. 
<p>
If that method has not yet been called on the medium, the state is "Inaccessible"; as opposed to truly inaccessible media, the value of <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">lastAccessError</a><b></b> will be an empty string in that case.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>As of version 3.1, this no longer performs an accessibility check automatically; call <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b> for that. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd0200d560c7f06631d6e979ebd8510a"></a><!-- doxytag: member="IMedium::location" ref="dd0200d560c7f06631d6e979ebd8510a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute wstring <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">IMedium::location</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Location of the storage unit holding medium data. 
<p>
The format of the location string is medium type specific. For medium types using regular files in a host's file system, the location string is the full file name.<p>
Some medium types may support changing the storage unit location by simply changing the value of this property. If this operation is not supported, the implementation will return E_NOTIMPL in attempt to set this attribute's value.<p>
When setting a value of the location attribute which is a regular file in the host's file system, the given file name may be either relative to the <a class="el" href="interface_i_virtual_box.html#0084caa96e342ed0ca186313805b174b">VirtualBox home folder</a><b></b> or absolute. Note that if the given location specification does not contain the file extension part then a proper default extension will be automatically appended by the implementation depending on the medium type. 
</div>
</div><p>
<a class="anchor" name="1fbf41d84302b52c2392454c60a415b8"></a><!-- doxytag: member="IMedium::name" ref="1fbf41d84302b52c2392454c60a415b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_medium.html#1fbf41d84302b52c2392454c60a415b8">IMedium::name</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Name of the storage unit holding medium data. 
<p>
The returned string is a short version of the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">location</a><b></b> attribute that is suitable for representing the medium in situations where the full location specification is too long (such as lists and comboboxes in GUI frontends). This string is also used by frontends to sort the media list alphabetically when needed.<p>
For example, for locations that are regular files in the host's file system, the value of this attribute is just the file name (+ extension), without the path specification.<p>
Note that as opposed to the <a class="el" href="interface_i_medium.html#dd0200d560c7f06631d6e979ebd8510a">location</a><b></b> attribute, the name attribute will not necessary be unique for a list of media of the given type and format. 
</div>
</div><p>
<a class="anchor" name="01b3d1aa474671a6f6efc7d768e02603"></a><!-- doxytag: member="IMedium::deviceType" ref="01b3d1aa474671a6f6efc7d768e02603" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="_virtual_box_8idl.html#d258d4c51629346fceac4679b3209ad9">DeviceType</a> <a class="el" href="interface_i_medium.html#01b3d1aa474671a6f6efc7d768e02603">IMedium::deviceType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kind of device (DVD/Floppy/HardDisk) which is applicable to this medium. 
<p>

</div>
</div><p>
<a class="anchor" name="083b805a42df44c7f30dcefa8bfb0b19"></a><!-- doxytag: member="IMedium::hostDrive" ref="083b805a42df44c7f30dcefa8bfb0b19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_medium.html#083b805a42df44c7f30dcefa8bfb0b19">IMedium::hostDrive</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
True if this corresponds to a drive on the host. 
<p>

</div>
</div><p>
<a class="anchor" name="9ad3aaac5c492ae22205995236470499"></a><!-- doxytag: member="IMedium::size" ref="9ad3aaac5c492ae22205995236470499" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long long <a class="el" href="interface_i_medium.html#9ad3aaac5c492ae22205995236470499">IMedium::size</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Physical size of the storage unit used to hold medium data (in bytes). 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For media whose <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> is <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575897a4ce4f8bb3050332d3eb020e98a3">MediumState_Inaccessible</a><b></b>, the value of this property is the last known size. For <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a57b237c061c87ac12294c3af8f8871494d">MediumState_NotCreated</a><b></b> media, the returned value is zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="acf66ac403576ec489410c12c701cbc7"></a><!-- doxytag: member="IMedium::format" ref="acf66ac403576ec489410c12c701cbc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_medium.html#acf66ac403576ec489410c12c701cbc7">IMedium::format</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Storage format of this medium. 
<p>
The value of this attribute is a string that specifies a backend used to store medium data. The storage format is defined when you create a new medium or automatically detected when you open an existing medium, and cannot be changed later.<p>
The list of all storage formats supported by this VirtualBox installation can be obtained using <a class="el" href="interface_i_system_properties.html#3fddf22466361f98b6dc9fc4458d1049">ISystemProperties::mediumFormats</a><b></b>. 
</div>
</div><p>
<a class="anchor" name="709be209ddc9fa9cbc607bfc9c9e741a"></a><!-- doxytag: member="IMedium::mediumFormat" ref="709be209ddc9fa9cbc607bfc9c9e741a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium_format.html">IMediumFormat</a> <a class="el" href="interface_i_medium.html#709be209ddc9fa9cbc607bfc9c9e741a">IMedium::mediumFormat</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Storage medium format object corresponding to this medium. 
<p>
The value of this attribute is a reference to the medium format object that specifies the backend properties used to store medium data. The storage format is defined when you create a new medium or automatically detected when you open an existing medium, and cannot be changed later.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd><code>null</code> is returned if there is no associated medium format object. This can e.g. happen for medium objects representing host drives and other special medium objects. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5430e5698b129a24c36d01fbc554cea"></a><!-- doxytag: member="IMedium::type" ref="b5430e5698b129a24c36d01fbc554cea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c">MediumType</a> <a class="el" href="interface_i_medium.html#b5430e5698b129a24c36d01fbc554cea">IMedium::type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type (role) of this medium. 
<p>
The following constraints apply when changing the value of this attribute: <ul>
<li>
If a medium is attached to a virtual machine (either in the current state or in one of the snapshots), its type cannot be changed.  </li>
<li>
As long as the medium has children, its type cannot be set to <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191cc67a8da6621c960f4decbd8068532d59">MediumType_Writethrough</a><b></b>.  </li>
<li>
The type of all differencing media is <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c629ba33e5d60a819e20c7c01913e4e39">MediumType_Normal</a><b></b> and cannot be changed.  </li>
</ul>
<p>
The type of a newly created or opened medium is set to <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c629ba33e5d60a819e20c7c01913e4e39">MediumType_Normal</a><b></b>, except for DVD and floppy media, which have a type of <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191cc67a8da6621c960f4decbd8068532d59">MediumType_Writethrough</a><b></b>. 
</div>
</div><p>
<a class="anchor" name="ff2eb5e354570fc966561ba2e3fdb557"></a><!-- doxytag: member="IMedium::parent" ref="ff2eb5e354570fc966561ba2e3fdb557" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a> <a class="el" href="interface_i_medium.html#ff2eb5e354570fc966561ba2e3fdb557">IMedium::parent</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parent of this medium (the medium this medium is directly based on). 
<p>
Only differencing media have parents. For base (non-differencing) media, <code>null</code> is returned. 
</div>
</div><p>
<a class="anchor" name="079bf4ff8d423005179b26044a5709fa"></a><!-- doxytag: member="IMedium::children" ref="079bf4ff8d423005179b26044a5709fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a> [] <a class="el" href="interface_i_medium.html#079bf4ff8d423005179b26044a5709fa">IMedium::children</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Children of this medium (all differencing media directly based on this medium). 
<p>
A <code>null</code> array is returned if this medium does not have any children. 
</div>
</div><p>
<a class="anchor" name="d1595ef4720ff87d93dab30ea0ab0f2e"></a><!-- doxytag: member="IMedium::base" ref="d1595ef4720ff87d93dab30ea0ab0f2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute <a class="el" href="interface_i_medium.html">IMedium</a> <a class="el" href="interface_i_medium.html#d1595ef4720ff87d93dab30ea0ab0f2e">IMedium::base</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Base medium of this medium. 
<p>
If this is a differencing medium, its base medium is the medium the given medium branch starts from. For all other types of media, this property returns the medium object itself (i.e. the same object this property is read on). 
</div>
</div><p>
<a class="anchor" name="98fcbfdaca62411eab95c8d84c21f850"></a><!-- doxytag: member="IMedium::readOnly" ref="98fcbfdaca62411eab95c8d84c21f850" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute boolean <a class="el" href="interface_i_medium.html#98fcbfdaca62411eab95c8d84c21f850">IMedium::readOnly</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns <code>true</code> if this medium is read-only and <code>false</code> otherwise. 
<p>
A medium is considered to be read-only when its contents cannot be modified without breaking the integrity of other parties that depend on this medium such as its child media or snapshots of virtual machines where this medium is attached to these machines. If there are no children and no such snapshots then there is no dependency and the medium is not read-only.<p>
The value of this attribute can be used to determine the kind of the attachment that will take place when attaching this medium to a virtual machine. If the value is <code>false</code> then the medium will be attached directly. If the value is <code>true</code> then the medium will be attached indirectly by creating a new differencing child medium for that. See the interface description for more information.<p>
Note that all <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191cc24c7a9b514f4dad4bed5c2c81ef372b">Immutable</a><b></b> media are always read-only while all <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191cc67a8da6621c960f4decbd8068532d59">Writethrough</a><b></b> media are always not.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The read-only condition represented by this attribute is related to the medium type and usage, not to the current <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">medium state</a><b></b> and not to the read-only state of the storage unit. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf9c923afac6944394db3856544764d1"></a><!-- doxytag: member="IMedium::logicalSize" ref="cf9c923afac6944394db3856544764d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute unsigned long long <a class="el" href="interface_i_medium.html#cf9c923afac6944394db3856544764d1">IMedium::logicalSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Logical size of this medium (in megabytes), as reported to the guest OS running inside the virtual machine this medium is attached to. 
<p>
The logical size is defined when the medium is created and cannot be changed later.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Reading this property on a differencing medium will return the size of its <a class="el" href="interface_i_medium.html#d1595ef4720ff87d93dab30ea0ab0f2e">base</a><b></b> medium.<p>
For media whose state is <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> is <a class="el" href="_virtual_box_8idl.html#eae80db6bda22be0b79ab1da82528a575897a4ce4f8bb3050332d3eb020e98a3">MediumState_Inaccessible</a><b></b>, the value of this property is the last known logical size. For <a class="el" href="">MediumaState_NotCreated</a><b></b> media, the returned value is zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccc83be4542142dfa1aee8238b1c42ec"></a><!-- doxytag: member="IMedium::autoReset" ref="ccc83be4542142dfa1aee8238b1c42ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attribute boolean <a class="el" href="interface_i_medium.html#ccc83be4542142dfa1aee8238b1c42ec">IMedium::autoReset</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether this differencing medium will be automatically reset each time a virtual machine it is attached to is powered up. 
<p>
This attribute is automatically set to <code>true</code> for the last differencing image of an "immutable" medium (see <a class="el" href="_virtual_box_8idl.html#b4abb9d1b9e44b997d1d2a809e66191c">MediumType</a><b></b>).<p>
See <a class="el" href="interface_i_medium.html#fd01e6dd69a92b3aec9011f156869d89">reset</a><b></b> for more information about resetting differencing media.<p>
<dl class="user" compact><dt><b>Expected result codes:</b></dt><dd><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><a class="el" href="group___virtual_box___c_o_m__result__codes.html#ga4ba5e3fab3fe318c790d9d0b500c102">VBOX_E_NOT_SUPPORTED </a> </td><td>This is not a differencing medium (when changing the attribute value).  </td></tr>
</table>
</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Reading this property on a base (non-differencing) medium will always <code>false</code>. Changing the value of this property in this case is not supported. </dd></dl>

</div>
</div><p>
<a class="anchor" name="43cef7fdd6fde64c591bc9529ea6e3ba"></a><!-- doxytag: member="IMedium::lastAccessError" ref="43cef7fdd6fde64c591bc9529ea6e3ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstring <a class="el" href="interface_i_medium.html#43cef7fdd6fde64c591bc9529ea6e3ba">IMedium::lastAccessError</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Text message that represents the result of the last accessibility check performed by <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b>. 
<p>
An empty string is returned if the last accessibility check was successful or has not yet been called. As a result, if <a class="el" href="interface_i_medium.html#c250d2252217354b21b272b9387c94d4">state</a><b></b> is "Inaccessible" and this attribute is empty, then <a class="el" href="interface_i_medium.html#67c4d153a846d2633736c0ec90dc7714">refreshState</a><b></b> has yet to be called; this is the default value of media after VirtualBox initialization. A non-empty string indicates a failure and should normally describe a reason of the failure (for example, a file read error). 
</div>
</div><p>
<a class="anchor" name="e0547f6629431c9508f68115745d266e"></a><!-- doxytag: member="IMedium::machineIds" ref="e0547f6629431c9508f68115745d266e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">readonly attribute wstringUUID [] <a class="el" href="interface_i_medium.html#e0547f6629431c9508f68115745d266e">IMedium::machineIds</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array of UUIDs of all machines this medium is attached to. 
<p>
A <code>null</code> array is returned if this medium is not attached to any machine or to any machine's snapshot.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The returned array will include a machine even if this medium is not attached to that machine in the current state but attached to it in one of the machine's snapshots. See <a class="el" href="interface_i_medium.html#7cfe993112605057132bc6f4b3c8cd36">getSnapshotIds</a><b></b> for details. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Jun 2 16:41:23 2010 for VirtualBox Main API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
